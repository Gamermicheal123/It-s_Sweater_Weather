<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Game</title>
</head>
  <script src="pixi/pixi.min.js"></script>
  <style>* {padding: 0; margin: 0}</style>
<body>
  <script type="text/javascript">
let type = "WebGL"
if(!PIXI.utils.isWebGLSupported()){
  type = "canvas"
}
//This program is made by Corin Acton
let Application = PIXI.Application,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    TextureCache = PIXI.utils.TextureCache
    Sprite = PIXI.Sprite,
    Container = PIXI.Container;

let app = new Application({
    width: 256,
    height: 256,
    antialias: true,
    transparent: false,
    resolution: 1
  }
);

document.body.appendChild(app.view);
app.renderer.view.style.position = "absolute";
app.renderer.view.style.display = "block";
app.renderer.autoResize = true;
app.renderer.resize(window.innerWidth, window.innerHeight);

let Width = app.renderer.view.width,
    Height = app.renderer.view.height,
    stage = app.stage,
    Mousepos = app.renderer.plugins.interaction.mouse.global;
loader
  .add("Images/Load/loadanim.json")
  .add("Images/Clothes/Items.json")
  .on("progress", loadProgressHandler)
  .load(setup);
  let loadanimfinished=false, loadtext=[];
function loadanim(){
  let sheet = PIXI.loader.resources["Images/Load/loadanim.json"].spritesheet
  loading = new PIXI.extras.AnimatedSprite(sheet.animations["load"])
  loading.animationSpeed = .15000020050324
  loading.width=r("W",200)
  loading.height=r("W",200)
  loading.x=Width/2-loading.width/2
  loading.y=r("H",140)
  loading.play()
  let loadtextstyle = new PIXI.TextStyle({
    fill: "white",
    fontSize: r("W", 25)
  });
  loadtext[0] = new PIXI.Text("Loading",loadtextstyle)
  loadtext[1] = new PIXI.Text("Please Wait",loadtextstyle)
  loadtext[0].y=Height/2+r("H",120);
  loadtext[1].y=Height/2+r("H",200);
  for(let i=0; i<2; i++){
    loadtext[i].x=r("W",265);
    app.stage.addChild(loadtext[i])
  }
  app.stage.addChild(loading)
  loadanimfinished=true
}
function loadProgressHandler(loader, resource) {
  if(loadanimfinished==false){loadanim();}
  console.log("loading: " + resource.url)
  console.log("progress: " + loader.progress + "%")
  loadtext[0].text="Loaded File:" + resource.url
  loadtext[1].text="Overall Progress " + loader.progress + "%"
}
let state, amountOfItems=18, itemsprite, items = [], item;
function setup() {
  console.log("All Files Loaded")
  loadtext[0].text="All Files Loaded"
  loadtext[1].text="Starting up..."
  id = resources["Images/Clothes/Items.json"].textures;
  for(let i = 0; i<amountOfItems; i++){
     itemsprite = new Sprite(id["Clothing ("+i+").png"]);
     item = new Container();
     boxify(50,itemsprite,item,5)
     items.push(item);
     item.x=i*r("W",50)
     createDragAndDropFor(item)
  }
  state = play
  app.renderer.backgroundColor=0x00BF97
  app.stage.removeChild(loading)
  for(let i=0; i<2; i++){app.stage.removeChild(loadtext[i])}
  app.ticker.add(delta => gameloop(delta));
}
function gameloop(delta){
  state(delta);
}
function play(delta){

}
function r(mode, value){//r relevant to screen size, made for ease of programming so code will function on different size screens
  let out;
  if(mode == "W"){//width
    out = value * Width/1000
  }else if(mode == "H"){//height
    out = value * Height/1000
  }
  return out;
}
function sts(mode,object,value){
  if(mode == "W"){
    object.height = r("W",value)*(object.height/object.width)
    object.width = r("W",value)
  }else if(mode =="H"){
    object.width = r("H",value)*(object.width/object.height)
    object.height = r("H",value)
  }else if(mode == "BoxifyHeight"){
    object.width = r("W",value)*(object.width/object.height)
    object.height = r("W",value)
  }
}
function boxify(size,object,boxname,edgeMargin){
  box = new Sprite(id["itemBox.png"]);
  sts("W",box,50)
  boxname.addChild(box)
  if(object.width>object.height){
    sts("W",object,size-edgeMargin*2)
    object.x=r("W",edgeMargin)
    object.y=r("W",size/2)-object.height/2
  }else{
    sts("BoxifyHeight",object,size-edgeMargin*2)
    object.x=r("W",size/2)-object.width/2
    object.y=r("W",edgeMargin)
  }
  app.stage.addChild(boxname)
}
let drag = false, Xoff, Yoff;
function createDragAndDropFor(target){
  target.interactive = true;
  target.on("mousedown", function(e){
    drag = target;
    Xoff=Mousepos.x-drag.x;
    Yoff=Mousepos.y-drag.y;
  })
  target.on("mouseup", function(e){
    drag = false;
  })
  target.on("mousemove", function(e){
    if(drag){
      drag.position.x = Mousepos.x-Xoff;
      drag.position.y = Mousepos.y-Yoff;
    }
  })
}
  </script>
</body>
</html>
